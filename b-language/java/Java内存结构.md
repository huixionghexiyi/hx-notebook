# Java内存结构

如果没有特殊说明的话，Java内存区域都是指 `HotSpot`虚拟机。

1.8之后的运行时内存如下图：


1. 线程私有
   1. 程序计数器
   2. 虚拟机栈
   3. 本地方法栈
2. 线程共享（堆 `Heap`）
3. 直接内存（元空间`MetaSpace`）

## 线程私有

### 程序计数器
`.java`文件会被Java虚拟机编译成 `.class`文件，也就是字节码文件。程序计数器就是这个字节码文件的行号指示器，表示当前运行到哪一行，这在条件、循环、跳转方法、异常处理、线程恢复中都非常有用。

有了这个计数器，虚拟机就知道当前执行到哪里了，不会发生内存溢出，因为是每个线程都有的，内存小且固定，随着线程消失而消失。

### 虚拟机栈

每个线程都有一个`虚拟机栈`，而虚拟机栈是由一个个`栈帧`组成的，而每个栈帧都包含：`局部变量表`、`操作数栈`、`动态链接`、`方法出口信息`。

平时说的Java栈，指的是所有的虚拟机栈（虚拟机栈中包含的都是栈帧）。

每一次函数被调用就会压入一个栈帧到虚拟机栈中，函数调用结束后会弹出一个栈帧。

结束一个函数有两种方式： `return`、`抛出异常`。

- 若Java虚拟机`不允许`内存大小动态扩展。当线程的虚拟机栈超过允许的最大深度时抛出 `StackOverFlowError`
- 若Java虚拟机`允许`内存大小动态扩展，当线程继续请求栈时内存用光抛出 `OutOfMemoryError`


**局部变量表**存放了编译器可知的8种**数据类型**和**引用类型**（注意：并不是对象本身，可以是`指向对象起始地址的指针`、`指向一个代表对象的句柄`、`其他与此对象相关的位置`）。

### 本地方法栈

本地方法栈是调用操作系统提供的本地方法，也就是java虚拟机中使用的native方法服务。和虚拟机栈类似，也会有自己的栈帧。

同样包含：`局部变量表`、`操作数栈`、`动态链接`、`方法出口信息`。

同样会抛出 `StackOverFlowError`和 `OutOfMemoryError`

## 线程共享（**堆**）

在java 1.8之后，线程共享的也就只有**堆**了。

java中所有的对象实例和数组都在堆中分配内存，以及字符串常量池。

除了一些在方法中的对象引用没有返回，或未被外面使用，那么这些对象是在虚拟机栈中直接分配内存。

堆也是垃圾回收的主要区域。这里涉及到的垃圾回收请参看[垃圾回收](./垃圾回收.md)

## 直接内存（**元空间**）

直接内存，顾名思义，就是将东西直接存储在内存当中，而不是存放在堆或栈中，而受到java设置内存上限的限制。

不属于java虚拟机规范中定义的内存区域，所以不是运行时数据区的一部分。

限制元空间是否发生溢出的是物理内存。

这里就不讨论1.8之前的历史了。在java虚拟机的规范中，存在`方法区`这么一个概念。而`元空间`是对方法区这个概念的一种具体实现。

**元空间**中主要包含**运行时常量池**（类的版本、字段、方法、接口等描述信息以及`常量池表`用于存放编译生成的各种字面量和符号引用）。简单来说 **运行时常量池**包含类的定义及其编译生成物。

由于是直接内存，所以不受java内存区域的上限限制，只受物理内存的上限限制，因此可以编译更多的类。