# 创建对象的时候发生了什么

1. 类加载检查
2. 分配内存
3. 初始化初值
4. 设置头对象
5. 执行init方法

## 1. 类加载检查

> 当执行`new`指令时，首先检查这个类是否已经被加载了。如果没有加载就先加载这个类。

深入点讲就是，判断`new`执行后面的参数，如 `new Student()`，其中`new`后面的参数就是`Student()`，`Student`称为这个类的符号引用。

查看这个符号引用代表的类在`常量池`中是否已经被加载、解析、初始化过。若没有就执行加载、解析、初始化的类加载过程。

这里的常量池就是我们在内存结构一章中讲的 `直接内存（元空间）`中的常量池，里面存放被加载后的类。

## 2. 分配内存
> 加载完类后，就知道这个类的对象需要多大的内存了，然后在堆中划分一块区域用于存储这个对象。

分配方式有： `指针碰撞`和`空闲列表`。

选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的**垃圾收集器**是否带有**压缩整理功能**决定。

创建对象的时候会有并发问题。（多个线程可能同时执行到创建对象的语句），虚拟机一般采用 **`CAS`+失败重试** 和 **`TLAB`**的方式避免创建重复的对象。

## 3. 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。

这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

## 4. 设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。

另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

## 5. 执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。

但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。

所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

[对象的内存布局](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md#32-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)