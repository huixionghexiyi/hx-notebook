# TCP相关

- 一般性介绍
- 连接创建
- 可靠传输
- 流量控制
- 拥塞控制


## 一般性介绍

1. **特点**

面向连接的，也就是说像打电话一样，传输数据前需要建立连接，传输结束后需要断开连接。

端到端的，点对点的连接。

可靠交付，传输的数据无差错，不丢失、不重复、按序到达。

双工信道，有一个传输的缓存流，接收的有接收的缓存流。

面向字节流。将传输的数据看称无结构的字节流。

## 连接创建

TCP生命周期有三个阶段：建立连接、数据传送、释放连接。

建立连接的过程：
    
- A发出建立连接请求，并准备本地缓存资源；等待B的响应；
- B确认同意建立连接；并准备本地缓存资源；等待A的响应；
- A收到响应；发送确认连接报文，此报文中可以带有数据；

断开连接：

A发出释放连接请求；不再发送数据；等待B响应；

B发出确认报文；A方向的连接就断开了，但是任然接收B的数据；

B再次发送释放请求的报文；确认自己没有数据要发送了；

A收到后，发送确认报文；连接断开；

其实还需要等待一段时间，连接才会彻底断开；这是由于有些报文可能还要重传；


1. **连接**

用套接字表示连接，连接是一种抽象的概念。套接字是{ip:端口}

## 可靠传输

1. **停止等待协议**

- 差错处理

每发完一个分组就停止发送，等待对方发挥确认报文。接收到后再接着发。

发送一个分组后，就设置一个超时计时器，如果超过时间没有收到确认的信息就重新传。对方收到错误的分组直接丢弃，什么都不做。

所以，发送一个分组后会保留一个副本，等待重新发送；

还要对分组编号，不然就不知道哪个分组发送了；

超时计时器设置的时候要比数据传输的平均往返时间长一点才行。重传时间的设置会比较复杂。

- 确认丢失和确认迟到

如果接收方发送的确认分组在传输的过程中丢失了。发送方会再次返送分组，接收方收到直接丢弃，再发送确认分组给发送方。这叫`确认丢失`。

如果确认的分组只是超过了设置的超时时间，那么发送方收到到后直接丢弃，然后不再发送重复的分组了。这叫`确认迟到`。

上面这种确认和重传的机制，称为 `自动重传请求`。

总结：停止等待协议的信道利用率极低，只有发送的那一小段时间使利用到信道的马，其他时间都在等待对方发送确认分组。所以下面的协议会使信道的利用率提高很多。

2. 连续ARQ协议

发送方，将N个顺序的分组作为一个窗口。窗口内的分组可以连续发送，不需要等待接收方确认。如果收到了一个确认，看看是第几个的确认，如果使第一个分组的，那么向后滑动一个位置，再全部顺序发送。

接收方，对连续接收的最后一个分组发送一个确认，叫 `累计确认`。如果收到到1，2，4，5的确认那么就发送2的确认。发送方就会把3、4、5重新发送。这叫G-back-N(回到N)，即回到确认的分组的位置重新发送后面的。当然窗口也会向后移动，毕竟确认了前面两个了。


> 由首部和数据包的数据部分组成。具体细节就不讲了。

> 如何实现这种可靠传输，也不讲了。内容很多

## 流量控制

发送方发送得太快，接收方不一定接收得过来，流量控制是控制发送方不要发送太快了。

1. 滑动窗口实现流量控制

在建立连接时，接收方就说，我最多同时接收400个字节，需要等我确认你才能就这发。并且接收方在返回确认信息的时候还能附带接收窗口大小。

如果接收方发送窗口为0 的报文段，那么发送方就不发送了。后面接收方缓存中又有了一些空间，发送一个窗口400的报文段，但是丢失了。然后双方都开始等待对方的报文。

为了打破这种情况，发送方在接收到窗口为0的报文段时，就设置一个持续计时器，时间到，就发送一个探测报文，接收方接收到后就发送当前的窗口大小，如果还是0 那么重新计时。

2. 传输效率

缓存中的数据太小，封装成报文不太划算，太大封装称报文效率也会很低。所以TCP会位置一个MSS变量，表示最大报文长度。由以下几种机制触发TCP发送报文：

缓存中的数据达到MSS字节时触发；

应用程序要求发送报文时触发；

超过计时器期限时发送；

## TCP的拥塞问题

若对网络中某一资源的需求超过该资源能提供的可用部分，而使网络性能变差，这种情况就叫做 `拥塞`。

不能简单的增加供给。

若某节点缓存太小，获得的分组不得不丢弃，那么发送端超时会重传，造成拥塞。但是扩大缓存后，由于处理器性能差，依然造成超时，产生拥塞。

防止过多的数据注入到网络中，使网络中的路由器或链路不至于过载。

流量控制针对点对点通信量的控制。抑制发送方发送的速率。

拥塞控制针对整个网络。

### 拥塞控制的方法

1. 慢开始
2. 拥塞避免
3. 快重传和快恢复

- **慢开始**

发送方设置一个拥塞窗口（cwnd），根据网络动态调整，发送方的发送窗口等于拥塞窗口（如果再考虑接收方的接收能力的话，拥塞窗口还可能更小）。即出现了拥塞，就减小拥塞窗口；没有出现就增大拥塞窗口。

只要没有按时收到确认报文，则判断出现了拥塞。（线路一般都很好，所以出错概率很低，低于1%，一般都是网络出现负载而丢弃分组。）

重点在于窗口如何变化：

刚开始，由小变大。cwnd一开始不超过2xMSS个字节数（一般为1个）。（MSS指可以将数据封装为报文的阈值），一开始不能超过两个报文段，通常为1个MSS长度。一个MSS的长度也就是一个报文的长度。

刚开始时，发送一个报文，收到确认报文，增加1个MSS数值的窗口大小。然后发送2个（一个RTT时间内），会收到2个确认。这时就增加2，以此类推。每个RTT时间其实是翻倍的增大了cwnd窗口大小

TCP用字节作为窗口的单位，MSS也是用字节作为单位。

设置慢开始的门限（ssthresh）

- cwnd < ssthresh时，使用慢开始。
- cwnd > ssthresh时，使用拥塞避免。
- cwnd = ssthresh时，都可以。

- **避免拥塞**

这在一个RTT时间内就是增加一个MSS大小的cwnd窗口。

无论在 **慢开始**还是**避免拥塞**阶段，只要出现拥塞就将ssthresh减小到出现拥塞时窗口的一半大小，不小于2个报文段。重设cwnd为1个报文段。

上面两种算法合起来称为AIMD算法（加法增大，乘法减小）

但是也不能完全避免拥塞问题。拥塞时全方位综合的网络问题。

- **快重传和快恢复**

如果发送的计时器时限到了，也没有收到确认报文。则判断由拥塞，这是将cwnd减小到1，ssthresh减半。这种情况不使用快重传。

快重传使用在：接收方收到一个失序的报文段是，比如收到M1，M2，当收到M4时，由于没有M3，所以发送M2的确认报文。再接收M4,M5,M6的时候也要发送M2的确认报文，发送方就知道了，M3没有收到，就快速重传M3（快重传），而不用等超时再发送。同时，收到连续3次的M2确认报文后将ssthresh（门限）减半。cwnd窗口不减小（由于cwnd没有减小到1，即使用**慢开始**，这叫**快恢复**）




