# 快速排序
> 需要一个选择一个锚点，让锚点左边的小于锚点所在的值，锚点右边的大于锚点所在的值。然后进行递归，对左边的进行同样的操作。
# 选择排序
> 两层循环，内循环种如果出现比外循环中当前索引指向的元素的数值小，则交换。直到外循环结束。
# 冒泡排序
> 两层循环，内循环从第二个元素开始，如果前一个元素比当前元素大，则交换，直到循环结束。此时，最大的元素被移动到了最后。外循环完毕时，排序完成。
# 归并排序
> 递归的将列表分为两份，将左边和右边分别排好序，再合并。
# 堆排序

# 插入排序&希尔排序
> 插入排序，两层循环，内层while循环，条件为，外层循环索引大于0，并且外层循环中当前索引所指向的元素小于前一个元素，交换，外出循环的减去1，直到循环结束。外出循环还原到减去1之前的值，并且再加上继续迭代。直到循环结束。

> 希尔排序，插入排序升级版。插入排序可以看成是希尔排序的特例。希尔排序中不是和前一个元素进行比较，而是与指定间隔的索引所对应的元素进行比较。间隔不断减小，直到减少为1(此时为插入排序)。
# 计数排序&桶排序&基数排序
>计数排序，创建一个tmp列表，列表长度为待排序列的（最大值-最小值+1）的值，用于存放每个元素的出现次数。遍历待排序列，tmp的（当前元素值-最小值）索引的值+1。再遍历tmp还原原来的值。

>桶排序，创建多个桶，指定每个桶中元素种类的数量，根据(最大值-最小值)/桶的数量，求出每个桶多少个元素。再遍历待排序列，将值放入到（(当前值-最小值)/桶的数量）的索引中。遍历所有桶，如果桶中只能放一个元素，那么直接追加到结果，否则将当前桶再次进行递归排序。再次之前要判断，当前如果只划分了一个桶，那么桶的容量-1，以保证，桶中的元素种类越来越少。

> 基数排序，指定10个桶，先根据待排序列的个位数与桶的索引的关系，放入桶中。再遍历所有桶，并覆盖原来的待排序列。再根据十位与桶的索引的关系，放入桶中，再重新覆盖原来的待排序列。直到最高位都被排序。